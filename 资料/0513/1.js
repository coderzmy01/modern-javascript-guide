/* 
 第一步：URL解析
    URI:URL+URN
      + URI统一资源标识符
      + URL统一资源定位符
      + URN统一资源名称
    传输协议：
      + HTTP  超文本传输协议
      + HTTPS  HTTP+SSL(加密证书),相对于HTTP来讲会更加安全
      + FTP 文件的传输，例如：FTP上传工具、FTP资源共享...
    域名：服务器有一个外网IP，基于外网IP找到服务器，而域名就是给外网IP设置一个好记忆的名字
    端口号：区分同一台服务器上的不同服务(或项目)的
      + 取值范围：0~65535
      + 默认值：我们自己不写端口号，浏览器默认加的  HTTP->80  HTTPS->443  FTP->21
    编码问题：如果URL地址或者问号传参的信息中，出现中文或者某些特殊符号，传输中可能会乱码，此时需要客户端先进行编码，服务器端再解码..
      + encodeURI / decodeURI：一般用于对整个URL的编码，它只编码中文和部分特殊符号，对于URL地址中的有效符号不编码
      + encodeURIComponent / decodeURIComponent：一般用于对URL问号传参的值进行部分编码，因为除了encodeURI可以编码的东西外，对于URL地址中的有效符号也能编码，所以不适合整个URL
      + escape / unescape：不是所有后端语言都支持这个API，所以只用于客户端两个页面间数据传输的编译

  第二步：缓存检查
    “缓存”存储在哪了？
      + 虚拟内存（内存条）：页面关闭，存储的东西会消失  Memory Cache
      + 物理内存（硬盘）：持久存储  Disk Cache
    关于“静态资源文件”的缓存有两种：强缓存、协商缓存
      + 不论哪一种都是服务器设置规则，客户端浏览器会自动配合完成，无需我们写代码
      + 一般真实项目中，强缓存、协商缓存都会设置「也可以只设置一个」，强缓存失效的情况下，再去走协商缓存的机制
    强缓存：Cache-Control(HTTP/1.1)、Expires(HTTP/1.0) 服务器设置的“响应头”信息
      + cache-control: max-age=2592000
      + expires: Sun, 15 May 2022 20:14:22 GMT
      + 不论是从服务器获取，还是从缓存中读取，HTTP状态码都是200
      问题：如果本地缓存生效，但是服务器更新了这个资源，如何保证客户端可以获取最新的？
        + HTML页面资源“绝对不能”做强缓存，因为其实页面渲染的入口，所有其它资源也是在渲染解析HTML代码的时候，再去请求的！！
    协商缓存：哪怕本地有缓存也要去和服务器进行协商
      第一次请求页面，本地没有缓存，向服务器发送请求，如果需要设置协商缓存，服务器会在响应头中返回：Last-Modified（记录资源最后一次更新的时间） / ETag（记录资源最后一次更新的标识）；客户端浏览器看到标识后，把标识和资源都缓存起来！！
      第二次请求，也会向服务器发送请求，并且在请求头中，基于If-Modified-Since/If-None-Math分别把存储的Last-Modified/ETag值传递给服务器；服务器获取标识后，和本地资源(最新更新时间/标识)做对比；
        + 如果资源没有更新过，则时间/标识是一致的，服务器返回304；客户端发现是304，则从本地缓存中获取；
        + 如果资源更新了，则时间/标识是不一样的，服务器返回200和最新的内容以及最新的Last-Modified/ETag；客户端在把最新的信息存储起来!!
      ......
    ===>真实项目开发，建议大家：HTML页面只设置协商缓存、其余的静态资源强缓存和协商缓存都去设置！！
    数据缓存：前端开发者，基于本地存储方案，对于“不经常更新”的数据请求，做的缓存处理
      + 第一次从服务器获取数据，存储在本地「设置一个有效周期」
        本地存储方案：受“源”和“浏览器”的限制
          + cookie
            具备有效期，设置cookie的时候自己设置
            最多只允许存储4KB的内容
            cookie和服务器有猫腻：在非跨域请求下，如果本地有cookie，不论服务器是否需要，每一次发送请求，都默认把cookie基于请求头传递给服务器「利：如果需要把cookie传递给服务器，我们比较省心；弊：cookie比较多，每一次请求都携带大量的信息进行传递，把请求变慢！」
            cookie不稳定：清除历史记录、安全卫士清理垃圾可能会清除掉cookie；浏览器的隐私或者无痕模式，不记录cookie！
          + localStorage
            持久化存储，除非自己手动删除或者卸载浏览器
            最多允许存储5MB的内容
            localStorage默认和服务器是没有关系的，除非自己手动把它存的信息传递给服务器！！
            localStorage相对比较稳定一些！！
          + sessionStorage
            会话存储，页面刷新存储的信息会在；页面关闭，存储的信息会消失；
          + 虚拟内存存储「例如：全局变量、vuex、redux」
            页面刷新或者关闭，存储的信息都会释放！！
          + ...
      + 以后再发送请求，我们校验本地是否有此数据的缓存(而且是否在有效期内)
        + 如果没有：向服务器发送新的请求，获取最新的数据
        + 如果有：直接从本地存储的数据中拿出来渲染

  第三步：DNS解析「域名解析」
    浏览器地址栏输入域名，会去DNS服务器上找到对应的外网IP，然后基于服务器的外网IP，找到服务器！！
    DNS解析记录也会有缓存「谷歌浏览器大概记录1min」
    ----
    前端优化：尽可能减少DNS解析需要的时间
      + 正常：减少DNS解析的次数（也就是所有资源，尽可能都部署到，相同服务器的相同服务下）
      + 真实：我们会把不同资源分不同的服务器部署「Web服务器、图片服务器、数据服务器...」
        + 合理使用资源
        + 提高并发数
        + ...
        导致域名解析的次数增加，DNS解析需要的时间也会增加
    DNS Prefetch：DNS预解析，利用<link>的异步性，在GUI渲染过程中，同时去解析域名

  第四步：TCP的三次握手「让客户端和服务器端建立一个“稳定可靠”的传输通道」
    + TCP：稳定可靠，因为经过三次握手确定传输的稳定性，消耗时间久！！ ---> 常规业务都是用它
    + UDP：快速传输，省略三次握手的步骤，直接进行传输；可能存在丢包的情况！！  --->  一般用于直播的业务中

  第五步：数据传输
    + HTTP请求报文：请求头、请求起始行、请求主体
    + HTTP响应报文：响应头、响应起始行、响应主体
    -----在控制台的NetWork中都可以看到

  第六步：TCP的四次挥手「断开客户端和服务器端的连接通道」
    + HTTP/1.1版本开始，默认开启了Connection: keep-alive长连接；当前请数据传输完成后，建立的通道不会被立即释放，下一次请求，继续基于这个通道传输，减少TCP三握四挥的规程，加快数据传输的速度！！
    + 我们在Nginx配置的时候，可以设置keep-alive的周期「根据传输的数量 或者 设置时间」
    + 在客户端把信息传递给服务器之后，四次挥手就已经开始了！！

  第七步：页面渲染
    + DOM TREE
    + CSSOM TREE
    + RENDER TREE
    + Layout「回流/重排」
    + 分层
    + Painting
*/


let package_storage = _.storage.get('package_storage', 10000);
if (package_storage) {
  // 本地缓存生效，直接从本地获取即可
  console.log('成功「缓存」:', package_storage);
} else {
  // 本地没有获取失效，则从服务器获取
  axios.get(`./package.json?_=${+new Date()}`)
    .then(response => {
      console.log('成功「服务器」:', response.data);
      // 获取后存储到本地
      _.storage.set('package_storage', response.data);
    });
} 
